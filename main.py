import glob
import numbers
import random
import uuid
import string
import json

from lxml import etree

# Function to process an individual XML file
xsd_file_path = 'autogenerated_schema.xsd'
# Search for all .xml files in the current folder
xml_files = glob.glob('./*.xml')


def generate_uuid(length):
    return str(uuid.uuid4())[:length]


def generate_random_string(length):
    # Get all the ASCII letters in lowercase and uppercase
    letters = string.ascii_letters
    # Randomly choose characters from letters for the given length of the string
    random_string = ''.join(random.choice(letters) for _ in range(length))
    return random_string


def process_xml_file(file_path):
    # Parse the XML file and validate it against the schema
    xsd_tree = etree.parse(xsd_file_path)
    schema = etree.XMLSchema(xsd_tree)

    xml_tree = etree.parse(file_path)
    print(f"XML Validation: {schema.validate(xml_tree)}")  # Print validation result
    if schema.validate(xml_tree):
        process_tree(xml_tree)


def translate_tab_item(xml_element) -> dict:
    # Arrange

    row_number = generate_random_string(6)
    make_id = "Field_" + generate_uuid(7)
    tab_name_element = xml_element.find('./stringAttribute/value')
    tab_name = tab_name_element.text if tab_name_element is not None else ""

    placeholder_url = "https://placehold.co/1000x70?text=" + str(tab_name)

    # build result
    result = {
        "label": "Image view",
        "type": "image",
        "layout": {
            "row": row_number,
            "columns": None
        },
        "id": make_id,
        "source": placeholder_url,
        "properties": {}  # empty for now
    }
    print(json.dumps(result, indent=4))  # This should print to file later
    return result


def translate_group_item(xml_element):
    # Arrange

    row_number = generate_random_string(6)
    make_id = "Field_" + generate_uuid(7)
    group_name_element = xml_element.find('./stringAttribute/value')
    group_name = group_name_element.text if group_name_element is not None else "No Name Set for Group"
    my_text = "## " + group_name

    # build result
    result = {
        "text": my_text,
        "label": "Text View",
        "type": "text",
        "layout": {
            "row": row_number,
            "columns": None
        },
        "id": make_id,
    }
    print(json.dumps(result, indent=4))  # This should print to file later
    return result


def translate_date(xml_element):
    # Arrange

    datefield_label_element = xml_element.find('./label')
    datefield_label = datefield_label_element.text if datefield_label_element is not None else ""

    row_number = generate_random_string(6)
    make_id = "Field_" + generate_uuid(7)
    make_key = generate_uuid(7) + "_key"
    if xml_element.find('./longStringAttribute/value') is not None:
        my_date_description = xml_element.find('./longStringAttribute/value')

    boolean_attributes = xml_element.findall('./booleanAttribute')

    # default attributes
    disabled_value = False
    readonly_value = False
    my_date_description = ""

    # Iterate through the found booleanAttribute subnodes
    for boolean_attribute in boolean_attributes:
        # Check if the 'name' attribute has the value 'readonly'
        name_attribute = boolean_attribute.find('./name')
        if name_attribute is not None and name_attribute.text == 'editable':
            value_attribute = boolean_attribute.find('./value')
            if value_attribute is not None:
                disabled_value = value_attribute.text.capitalize() == "True"
        elif name_attribute is not None and name_attribute.text == 'readOnly':
            # Retrieve the 'value' attribute
            value_attribute = boolean_attribute.find('./value')
            if value_attribute is not None:
                readonly_value = value_attribute.text.capitalize() == "True"

    # build result
    result = {
        "subtype": "datetime",
        "dateLabel": datefield_label,
        "label": "Date time",
        "type": "datetime",
        "layout": {
            "row": row_number,
            "columns": None
        },
        "id": make_id,
        "key": make_key,
        "timeLabel": "myTimespinnerLabel",
        "timeSerializingFormat": "utc_offset",
        "timeInterval": 5,
        "description": my_date_description,
        "disabled": disabled_value,
        "readonly": readonly_value
    }
    print(json.dumps(result, indent=4))  # This should print to file later
    return result


def translate_textarea(xml_element):
    textfield_label_element = xml_element.find('./label')
    textfield_label = textfield_label_element.text if textfield_label_element is not None else ""

    row_number = generate_random_string(6)
    make_id = "Field_" + generate_uuid(7)
    make_key = generate_uuid(7) + "_key"

    #default values
    default_attribute = ""
    required_attribute = False
    min_length_attribute = 0
    max_length_attribute = 99999

    long_string_attributes = xml_element.findall('./longStringAttribute')
    boolean_attributes = xml_element.findall('./booleanAttribute')
    string_attributes = xml_element.findall('./stringAttribute')
    number_attributes = xml_element.findall/'./numberAttribute'

    # Description of the field
    for long_String_attribute in long_string_attributes:
        name_attribute = long_String_attribute.find('./name')
        if name_attribute is not None and name_attribute.text == 'description':
            if long_String_attribute.find('./value') is not None and long_String_attribute != "":
                description_attribute = long_String_attribute.find('./value').text


    # Iterate through the found booleanAttribute subnodes
    for boolean_attribute in boolean_attributes:
        # Check if the 'name' attribute has the value 'readonly'
        name_attribute = boolean_attribute.find('./name')
        if name_attribute is not None and name_attribute.text == 'editable':
            value_attribute = boolean_attribute.find('./value')
            if value_attribute is not None:
                disabled_value = value_attribute.text.capitalize() == "True"
        elif name_attribute is not None and name_attribute.text == 'readOnly':
            # Retrieve the 'value' attribute
            value_attribute = boolean_attribute.find('./value')
            if value_attribute is not None:
                readonly_value = value_attribute.text.capitalize() == "True"

    # build result
    result = {
        "label": textfield_label,
        "type": "textarea",
        "layout": {
            "row": row_number,
            "columns": None
        },
        "id": make_id,
        "key": make_key,
        "description" : description_attribute,
        "defaultValue": default_attribute,
        "validate": {
            "required": required_attribute,
            "minLength": min_length_attribute,
            "maxLength": max_length_attribute
        }
    }
    print(json.dumps(result, indent=4))  # This should print to file later
    return result


def translate_timespinner(xml_element):
    name_element = xml_element.find('./name')
    if name_element is not None:  # Check if the 'name' element was found
        name = name_element.text  # Access the text content of the 'name' element
        print(name)
    else:
        print("Name element not found")
    pass


def translate_radiobutton(xml_element):
    name_element = xml_element.find('./name')
    if name_element is not None:  # Check if the 'name' element was found
        name = name_element.text  # Access the text content of the 'name' element
        print(name)
    else:
        print("Name element not found")
    pass


def translate_textfield(xml_element):
    name_element = xml_element.find('./name')
    if name_element is not None:  # Check if the 'name' element was found
        name = name_element.text  # Access the text content of the 'name' element
        print(name)
    else:
        print("Name element not found")
    pass


def translate_booleancombo(xml_element):
    name_element = xml_element.find('./name')
    if name_element is not None:  # Check if the 'name' element was found
        name = name_element.text  # Access the text content of the 'name' element
        print(name)
    else:
        print("Name element not found")
    pass


def translate_combo(xml_element):
    name_element = xml_element.find('./name')
    if name_element is not None:  # Check if the 'name' element was found
        name = name_element.text  # Access the text content of the 'name' element
        print(name)
    else:
        print("Name element not found")
    pass


def translate_label(xml_element):
    name_element = xml_element.find('./name')
    if name_element is not None:  # Check if the 'name' element was found
        name = name_element.text  # Access the text content of the 'name' element
        print(name)
    else:
        print("Name element not found")
    pass


def map_element(xml_element):
    # Find the 'name' child element and get its text content
    match xml_element.find('./xtype').text:
        case 'ddtabitem':
            translate_tab_item(xml_element)
        case 'ddgroup':
            translate_group_item(xml_element)
        case 'tpl-datefield':
            translate_date(xml_element)
        case 'tpl-textarea':
            translate_textarea(xml_element)
        case 'tpl-label':
            translate_label(xml_element)
        case 'tpl-timespinner':
            translate_timespinner(xml_element)
        case 'tpl-radiobtn':
            translate_radiobutton(xml_element)
        case 'tpl-textfield':
            translate_textfield(xml_element)
        case 'tpl-booleancombo':
            translate_booleancombo(xml_element)
        case 'tpl-combo':
            translate_combo(xml_element)
        case _:
            print("Could not map element")


def process_panel(panel):
    # Check if xtype has the value "ddtabitem"
    xtype = panel.find('./xtype').text
    if xtype == 'ddtabitem':
        # Call mapElement function (to be implemented later)
        map_element(panel)
    else:
        print("panel has wrong format")

        # Iterate through FormGroup elements within the Panel
    for form_group in panel.findall('./FormGroup'):
        map_element(form_group)  # Call mapElement for each FormGroup

        # Iterate through FormField elements within the FormGroup
        for form_field in form_group.findall('./formField'):
            map_element(form_field)  # Call mapElement for each FormField


# Iterate through all Panel elements within the XML
def process_tree(xml_tree):
    for panel in xml_tree.findall('.//Panel'):
        process_panel(panel)


# Iterate through the found XML files and process each one
def main():
    for xml_file in xml_files:
        print(f"Processing file: {xml_file}")
        process_xml_file(xml_file)


if __name__ == '__main__':
    main()
